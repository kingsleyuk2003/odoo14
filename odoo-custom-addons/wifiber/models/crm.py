# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
# Copyright 2022  Kinsolve Solutions
# Copyright 2022 Kingsley Okonkwo (kingsley@kinsolve.com, +2348030412562)
# License: see https://www.gnu.org/licenses/lgpl-3.0.en.html

from datetime import datetime,date, timedelta

from dateutil.relativedelta import relativedelta

from odoo import api, fields, models, _
from odoo.exceptions import UserError
from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
import pytz

class CrmLeadExtend(models.Model):
    _inherit = 'crm.lead'

    def run_crm_lead_check(self):
        crm_lead_obj = self.env['crm.lead']
        crm_team = self.env['crm.team']
        the_date = datetime.today().strftime('%d-%m-%Y %H:%M:%S')

        crm_teams = crm_team.search([])
        for team in crm_teams:
            for sp in team.member_ids:
                active_activities = crm_lead_obj.search([('activity_ids', '!=', False),('user_id', '=', sp.id)])
                msg = "<style> " \
                      "table, th, td {" \
                      "border: 1px solid black; " \
                      "border-collapse: collapse;" \
                      "}" \
                      "th, td {" \
                      "padding-left: 5px;" \
                      "}" \
                      "</style>"
                msg += "<p>Hello %s,</p>" % (sp.name)
                msg += "<p>Please see the CRM Activities that are already due as at %s</p><p></p>" % (the_date)
                msg += "<table width='100%' >"
                msg += "<tr><td colspan='5' align='center' style='margin:35px' ><h3>List of Due Activities</h3></td></tr>" \
                       "<tr align='left' ><th>S/N</th><th>Activity Name</th><th>Deadline</th><th>Date and Time</th><th>Activity Type</th></tr>"

                at_least_one = False
                count = 0
                for act in active_activities.activity_ids:
                    act_name = act.note
                    deadline = act.date_deadline.strftime('%d-%m-%Y')
                    datetime_wifiber = act.datetime_wifiber.strftime('%d-%m-%Y %H:%M:%S')
                    #summary = act.summary
                    act_type = act.activity_type_id.name
                    count += 1
                    at_least_one = True
                    msg += "<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>" % (
                    count, act_name, deadline, datetime_wifiber, act_type)
                msg += "</table> <p></p><br /><p>Just for your information, regarding activities that are due.  Please log in and complete your done activities</p>" \
                       "<p>Regards and Thanks</p>" \
                       "<p>This is an autogenerated message from %s ERP System</p>" % (self.env.user.company_id.name)

                # Send Email
                company_email = self.env.user.company_id.email.strip()
                if company_email and at_least_one:
                    user_ids = []
                    mail_obj = self.env['mail.mail']
                    mail_data = {
                        'model': 'crm.lead',
                        'res_id': self.id,
                        'record_name': 'CRM Due Activities Reminder Notification',
                        'email_from': company_email,
                        'reply_to': company_email,
                        'subject': "CRM Due Activities Notification for the Date %s" % (the_date),
                        'body_html': '%s' % msg,
                        'auto_delete': True,
                        # 'recipient_ids': [(4, id) for id in new_follower_ids]
                        'email_to': sp.partner_id.email
                    }
                    mail_id = mail_obj.create(mail_data)
                    mail_obj.send([mail_id])

        return True

    def create_quotation(self):
        if not self.is_survey_ticket_created :
            raise UserError('Sorry, you have to create survey ticket. Please click create survey ticket button')

        if self.is_survey_ticket_created  and not self.is_survey_ticket_close :
            raise UserError('The survey ticket (%s) attached for this opportunity is not closed yet. Contact the CSC team to close the survey ticket for this opportunity before you can mark this opportunity as won' % (self.survey_ticket_id))
        return super(CrmLeadExtend, self).create_quotation()

    def unlink(self):
        for rec in self:
            if not self.is_survey_ticket_created:
                raise UserError('Sorry, you have to create survey ticket. Please click create survey ticket button')

            if rec.is_survey_ticket_close :
                raise UserError('Sorry, you cannot delete this opportunity, because a survey ticket has been closed for this opportunity')
        return super(CrmLeadExtend,self).unlink()

    def action_view_ticket(self):
        ticket_ids = self.mapped('ticket_ids')
        action = self.env["ir.actions.actions"]._for_xml_id("kin_helpdesk.action_view_all_tickets")

        if len(ticket_ids) > 1:
            action['domain'] = [('id', 'in', ticket_ids.ids)]
        elif len(ticket_ids) == 1:
            form_view = [(self.env.ref('kin_helpdesk.ticket_form').id, 'form')]
            if 'views' in action:
                action['views'] = form_view + [(state,view) for state,view in action['views'] if view != 'form']
            else:
                action['views'] = form_view
            action['res_id'] = ticket_ids.id
        else:
            action = {'type': 'ir.actions.act_window_close'}
        #action['target'] = 'new'

        context = {
            #'default_move_type': 'out_invoice',
        }
        # if len(self) == 1:
        #     context.update({
        #         'default_partner_id': self.partner_id.id,
        #         'default_partner_shipping_id': self.partner_shipping_id.id,
        #         'default_invoice_payment_term_id': self.payment_term_id.id or self.partner_id.property_payment_term_id.id or self.env['account.move'].default_get(['invoice_payment_term_id']).get('invoice_payment_term_id'),
        #         'default_invoice_origin': self.mapped('name'),
        #         'default_user_id': self.user_id.id,
        #     })
        action['context'] = context
        return action


    @api.depends('ticket_ids')
    def _compute_ticket_count(self):
        for rec in self:
            rec.ticket_count = len(rec.ticket_ids)

    def action_create_survey_ticket(self, details,msg):
        if self.is_survey_ticket_created :
            raise UserError('Survey Ticket (%s) has been created already before now' % (self.survey_ticket_id))
        if len(self.ticket_ids) > 0:
            raise UserError(
                _('Sorry, you can only generate a survey ticket once.'))
        res = {}

        self.stage_id = self.env.ref('wifiber.stage_survey')
        name = self.name

        csc = False
        is_default_survey_group = False
        # assign default survey ticket group for csc fob
        is_default_survey_group = self.env['user.ticket.group'].search([('is_survey_group_default_csc', '=', True)], limit=1)

        if not is_default_survey_group:
            raise UserError('Please contact the Admin to set the Default survey group for CSC' )
        if is_default_survey_group:
            csc = is_default_survey_group.id

        category_id = self.env.ref('wifiber.survey')
        # Create ticket
        vals = {
            'name': name,
            'category_id': category_id.id,
            'partner_id': self.partner_id and self.partner_id.id or False,
            'initiator_ticket_group_id': csc,
            'description': details + "\n" + msg  ,
        }
        ticket_obj = self.env['kin.ticket'].create(vals)
        ticket_obj.crm_id = self.id
        self.is_survey_ticket_created = True
        self.survey_ticket_created_date = datetime.today()
        self.survey_ticket_id = ticket_obj.ticket_id

        partn_ids = []
        user_names = ''
        if is_default_survey_group:
            # send group email
            users = is_default_survey_group.sudo().user_ids
            for user in users:
                if user.is_group_email:
                    user_names += user.name + ", "
                    partn_ids.append(user.partner_id.id)

            if partn_ids:
                msg = _(
                    'A New Survey Ticket has been created with subject (%s), from %s'
                ) % (self.name, self.env.user.name)

                self.message_follower_ids.unlink()
                self.message_post(body=msg, subject=name, partner_ids=partn_ids, subtype_xmlid='mail.mt_comment',force_send=False)
                self.env.user.notify_info('%s Will Be Notified by Email' % (user_names))

        return res

    @api.depends('activity_ids.datetime_wifiber')
    @api.depends_context('uid')
    def _compute_activity_datetime_wifiber(self):
        todo_activities = []
        if self.ids:
            todo_activities = self.env['mail.activity'].search([
                ('user_id', '=', self._uid),
                ('res_model', '=', self._name),
                ('res_id', 'in', self.ids)
            ], order='datetime_wifiber ASC')

        for record in self:
            record.activity_datetime_wifiber = next(
                (activity.datetime_wifiber for activity in todo_activities if activity.res_id == record.id),
                False
            )

    ticket_ids = fields.One2many('kin.ticket', 'crm_id', string='Tickets')
    material_requested = fields.Text(string='Material Requested')
    ticket_count = fields.Integer(compute="_compute_ticket_count",
                                  string='# of Ticket',
                                  copy=False,
                                  default=0)
    is_survey_ticket_close = fields.Boolean(string='Survey Ticket Closed')
    is_survey_ticket_created = fields.Boolean(string='Survey Ticket Created')
    survey_ticket_created_date = fields.Datetime(string='Survey Ticket Created Date')
    survey_ticket_id = fields.Char(string='Survey Ticket ID')
    partner_name = fields.Char(
        'Customer', tracking=20, index=True,
        compute='_compute_partner_name', readonly=False, store=True,
        help='The name of the future partner company that will be created while converting the lead into opportunity')
    #is_company = fields.Boolean(string='Is a Company')
    activity_datetime_wifiber = fields.Datetime(
        'Date and Time', compute='_compute_activity_datetime_wifiber',
        search='_search_activity_date_deadline_my', compute_sudo=False,
        readonly=True, store=False, groups="base.group_user")

class MailActivity(models.Model):
    _inherit = 'mail.activity'

    datetime_wifiber = fields.Datetime('Date and Time', index=True)


